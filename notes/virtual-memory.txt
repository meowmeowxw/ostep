--------------------------------------------------------------------------------
Address Space
--------------------------------------------------------------------------------

In a modern os there are multiple processes running on the system. Using
scheduling policy we can virtualize the cpu, however we need to virtualize
memory too.

Why?

For example we wants to implement protections, you don't want a process to be 
read, or worse, write some other process's memory. Another feature was the
interactivity, if you don't virtualize memory then every time the os issue a 
context switch, then the os need to save all the information of a process in a
physical memory and then run the other process. This process is very slow, so
we need to find solutions to this problem.

The abstraction of physical memory is called address space, and it is the
running program's view of memory in the system.

Example:

0KB     -------------------
            Program Code
1KB     -------------------
            Heap
2KB     -------------------
                |
                v

            Free

                ^
                |
15KB    -------------------
            Stack
16KB    -------------------

In this case the stack and heap of a program can shrink at runtime, and the
process in not loaded in physical memory 0->16KB since those addresses are
virtualized.

The goal of a virtual memory (VM) system are:

1. Transparency, the os should implement virtual memory in a way that is
   invisible to the running program.
2. Efficieny both in time and space.
3. Protection.

--------------------------------------------------------------------------------
Memory API
--------------------------------------------------------------------------------

In running a C program, there are two types of memory that are allocated. The
first is called stack memory, and allocations and deallocations of it are
managed implicitly by the compiler for you. The stack is also called automatic
memory.

Example of code:

#include <stdio.h>
#include <string.h>

void print(char *src) {
    char dst[64];
    strcpy(dst, src);
    printf("dst: %s\n", dst);
}

int main(int argc, char **argv) {
    char src[] = "hi ostep readers!";
    print(src);
	return 0;
}

disassembly of print:

opcodes         instructions

55             push rbp
4889e5         mov rbp, rsp
4883ec50       sub rsp, 0x50
48897db8       mov qword [src], rdi        ; arg1
488b55b8       mov rdx, qword [src]
488d45c0       lea rax, [dest]
4889d6         mov rsi, rdx                ; const char *src
4889c7         mov rdi, rax                ; char *dst
e8c8feffff     call sym.imp.strcpy         ;
488d45c0       lea rax, [dest]
4889c6         mov rsi, rax
488d3d8e0e00   lea rdi, str.dst
b800000000     mov eax, 0
e8c0feffff     call sym.imp.printf
90             nop
c9             leave
c3             ret

With the instructions push and pop we insert and extract instructions to/from
the stack. 
With the first three isntruction we push the precedent base pointer of the main 
function, and we "allocate" on the stack 0x50 bytes of space, so the compiler
has increased the dimension of the stack to contain our *dst.
At the end of the function the program issue a leave instruction which moves
the stack pointer to the current base pointer and then it pop the base pointer.
The last instruction is ret which pop from the stack the return address and 
set the instruction pointer to it.

Another type of memory is the heap which is created dynamically using the malloc
instruction.

int *x = (int *)malloc(sizeof(int));

With this instruction we allocate on the heap the size of an int (usually 4B).
When we don't need that space anymore we can free the space on the heap using
free:

free(x);

There are lots of bug around the heap, for example is always good practice to 
check the return value of the malloc, if the dimension requested is too large
the malloc returns NULL. Another good practice is to never reuse a variable
after it has been freed (UAF - Use After Free bugs), or never free twice the
same pointer (Double Free).

To detect potential bugs we can use a tool called valgrind.

Notes that we didn't use syscalls, but library function. At the base of the
malloc there are two syscall:

1. brk/sbrk which increase/decrease the size of the heap.
2. mmap which can create an anonymous memory region (memory not associated with
   any particular file) and that can be treated like a heap.

Never use these two syscalls to manage the heap or the program will crash
with the probability of 99.99%.

--------------------------------------------------------------------------------
Address Translation
--------------------------------------------------------------------------------

The generic technique we will use is something that is referred to as 
hardware-based address translation, or just address translation for short. With
address translation the hardware converts each memmory access changing the
virtual address provided by the instruction to a physical address where the 
desired information is actually located.

Of course, the hardware alone cannot virtualize memory, as it just provides the
low-level mechanism for doing so efficiently. The OS must get involved at key
points to set up the hardware so that the correct translations take place; it
must thus manage memory, keeping track of which locations are free and which are
in use, and judiciously intervening to maintain control over how memory is used.

As scheduling policy we need to do some assumptions to get to a final solution.
The first one is that the user's address space must be placed contiguosly in
physical memory, and that the size of the address space is less than the 
physical memory. Another assumption is that each address space is exactly the
same size.

Process 1 address space:

0KB     -------------------
            Program Code
1KB     -------------------
            Heap
2KB     -------------------
                |
                v

            Free

                ^
                |
15KB    -------------------
            Stack
16KB    -------------------


From the process perspective its address space start at 0KB and end at 16KB,
however the os wants to place the process somewhere else in physical memory not
necessarily at address 0. Example:

Physical memory:

0KB     ------------------
            OS
16KB    ------------------
            Not in Use
32KB    ------------------
            Process 1
48KB    ------------------
            Not in Use
64KB    ------------------

Thus, we want to relocate this process in memory in a way that is transparent
to the process itself.

The first idea introduced on the 1950's is referred as base and bounds, also
called dynamic relocation. Specifically we need two hardware register within
each CPU: one is called base register and the other the bounds/limit. In this
way the program is compiled as if it is loaded at address 0. However, when a 
program starts running, the os decides where in physical memory it should be
loaded and sets the base register to that value. In the above example the os
decides that the process must be relocated to address 32KB and set the base
register = 32KB. Now any memory reference is translated by the processor in the
following manner:

physical address = virtual address + base

If we have an instruction at address 300 like:

300: mov [ebx], eax

The instruction pointer (ip) or program counter (pc) is set to 300 and when
the hardware needs to fetch this instruction, it first add the value to the base
register and obtains the physical address 32KB + 300.
Before fetching the instruction the CPU will check if the memory reference is
within bounds to make sure it is legal (protection), if it's greater than the 
bounds the cpu raise an exception. The base and bounds registers are hardware
structures kept on the chip, and the process that helps the processor with 
address translation is called Memory Management Unit (MMU).

The hardware should provide special privileged (kernel) instruction to change
the base and bound registers, allowing the OS to change them when different
processes run. The os must manage the free space using some kind of data
structures (ex. free list), and when a process terminates update the data
structure. The os must save and restore the base and bounds register in for each
process (for context switch) and uses a structure called Process Control Block
(PCB). A last thing the os must handle the exception generated by the cpu,
usually it kills the process that has tried to access an invalid memory region.

--------------------------------------------------------------------------------
Segmentation
--------------------------------------------------------------------------------

Problem: there are lots of free space inside an address space of a process, for
example all the heap/stack unused.

The address space is divded between three logically-different segments: code,
stack, and heap. We can use a base and bounds pair per segment, to place each
segment indipendently in physical memory, example:

0KB     |-----------------|

        |    OS

16KB    |-----------------|
        |    Not in Use
26KB    |-----------------|
        |    Stack
28KB    |-----------------|
        |    Not in Use
32KB    |-----------------|
        |    Code
34KB    |-----------------|
        |    Heap
37KB    |-----------------|

        |    Not in Use

64KB    |-----------------|

Process address space:

0KB     |------------------|
        |    Program Code
2KB     |------------------|
        |    Unused
4KB     |------------------|
        |    Heap
7KB     |------------------|
        |        |
        |        v

        |    Free

        |        ^
        |        |
14KB    |------------------|
        |    Stack
16KB    |------------------|

Table:

Segment     Base    Size
-------------------------
Code        32K     2K
Heap        34K     3K
Stack       28K     2K

Let's suppose that we want to fetch some memory from the virtual address 4200
(heap). First we subtract from 4200 the virtual base address of the heap (4096),
so 4200-4096=104. Then we add to 104 the physical base register physical address
of the heap (34K) and we obtain the real physical address = 34920.

If we tried to refer to an illegal address as 11KB, the hardware detects that
the address is out of bounds, traps into the os, and kill the process.
SEGMENTATION FAULT ERROR.

How the hardware knows which pair of segment/offset to use to translate an
address? The technique used in the VAX/VMS system is an explicit approach, It's
uses the top bits of a virtual address to select which segments to translate.
Since we have three segments we need the top two bit.

00 -> Code
01 -> Heap
10 -> Stack
11 -> Stack

Example, if we have a 14bit virtual address, and as before we want to read the
virtual address 4200.

01          000001101000
segment     offset

01 is the heap segment and 000001101000 is the offset = 104, thus the hardware
simply takes the first two bits to determine which segment register to use and
the next 12 bits to as the offset into the segment.

Simple code:

SEG_MASK = 0x3000 = 0b11000000000000
SEG_SHIFT = 12
OFFSET_MASK = 0xfff = 0b00111111111111
Segment = (VirtualAddress & SEG_MASK) >> SEG_SHIFT
Offset = VirtualAddress & OFFSET_MASK
if (Offset >= Bounds[Segment])
    RaiseException(PROTECTION_FAULT)
else
    PhysAddr = Base[Segment] + Offset
    Register = AccessMemory(PhysAddr)

Most system to increase the address space only use one bit to decide which
segment to use and merge the heap with the code. Other systems use an implicit
approach, if an address is generated with the program counter is on the code
segment, if the address is based off of the stack/base pointer it must be on
the stack, otherwise on the heap.

The stack grows backwards (towords lower addresses), so in physical memory
it starts at 28K and grows back to 26K, while in virtual memory from 16K to 14K.
So the hardware must know which way the segment grows (a bit set to 1 if it
grows in positive direction and 0 if it grows in negative direction).

Virtual address 15KB should map to 27K in physical memory. In bit the address is
represented as: 11 1100 0000 0000. 11 designate the segment stack, and we have
an offset of 0xc00 = 3072 = 3K. In this case we substract from it the maximum
size of a segment = 4K, 3K - 4K = -1K. The base is 28K, and the physical address
is 28K - 1K = 27K.

Another important feature is the technique of code sharing to share certain
memory segments between address space. To do that the hardware needs an extra
support in the form of protections bits, for example the code segment can be
readable and executable, but not writable, while the stack can be readable and
writable.

With segmentation however we have a new problem, the size of a segment can
change (ex. using sbrk), and then the physical memory will become full of little
holes of free space, making it difficult to allocate new segments or to grow
existing ones. We call this problem external fragmentation. There are lots of 
algorithms to handle this problem like the best-fit, worst-fit, first-fit and
more complex like buddy algorithm, however no perfect solution exists for this
problem.

--------------------------------------------------------------------------------
Free-Space Management
--------------------------------------------------------------------------------

This is very hard to summarize so I will only list the characteristic of some
algorithms.
Free-Space Management is required when we have a problem of external
fragmentation, it could be the case with segmentation or the heap. In the latest
case the heap is managed by the pair of functions malloc/free.

There are several approach to manage the free space, the easiest is to use a
free list:

head -> 10 -> 30 -> 20 -> NULL

In the above example the list contains 3 free chunks, of size 10, 30, 20.

The most used algorithms on the free list are the following:

1. Best-fit: search through the free list and find chunks of free memory that
   are as big or bigger than the requested size. Then, return the one that is
   the smallest in that group of candidates;
2. Worst-fit: is the opposite of the best-fit, the scope is to leave big chunks
   free instead of losts of small chunks.
3. First-fit: simply finds the first block that is big enough and returns the
   requested amount to the user.
4. Next-fit: keep an extra pointer to the location within the list where one was
   looking last. The idea is to spread the search across all the free-list.

A more advanced method is the use of segregated list. If a particular
application has one (or a few) popular-sized request that it makes, keep a
separate list just to manage objects of that size; all other requests are
forwarded to a more general memory allocator. This is the case for the 
implementation of the glibc malloc, which uses fastbins to manage chunks with
popular size.

Link: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/

Another method is tu use a buddy allocation, the base of this allocator is to
recursively using a binary tree find enough space for the chunks requested.

