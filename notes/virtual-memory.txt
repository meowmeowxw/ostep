-------------------------------------------------------------------------------
Address Space
-------------------------------------------------------------------------------

In a modern os there are multiple processes running on the system. Using
scheduling policy we can virtualize the cpu, however we need to virtualize
memory too.

Why?

For example we wants to implement protections, you don't want a process to be 
read, or worse, write some other process's memory. Another feature was the
interactivity, if you don't virtualize memory then every time the os issue a 
context switch, then the os need to save all the information of a process in a
physical memory and then run the other process. This process is very slow, so
we need to find solutions to this problem.

The abstraction of physical memory is called address space, and it is the
running program's view of memory in the system.

Example:

0KB     -------------------
            Program Code
1KB     -------------------
            Heap
2KB     -------------------
                |
                v

            Free

                ^
                |
15KB    -------------------
            Stack
16KB    -------------------

In this case the stack and heap of a program can shrink at runtime, and the
process in not loaded in physical memory 0->16KB since those addresses are
virtualized.

The goal of a virtual memory (VM) system are:

1. Transparency, the os should implement virtual memory in a way that is
   invisible to the running program.
2. Efficieny both in time and space.
3. Protection.

-------------------------------------------------------------------------------
Memory API
-------------------------------------------------------------------------------

In running a C program, there are two types of memory that are allocated. The
first is called stack memory, and allocations and deallocations of it are
managed implicitly by the compiler for you. The stack is also called automatic
memory.

Example of code:

```
#include <stdio.h>
#include <string.h>

void print(char *src) {
    char dst[64];
    strcpy(dst, src);
    printf("dst: %s\n", dst);
}

int main(int argc, char **argv) {
    char src[] = "hi ostep readers!";
    print(src);
	return 0;
}
```

disassembly of print:

```
opcodes         instructions

55             push rbp
4889e5         mov rbp, rsp
4883ec50       sub rsp, 0x50
48897db8       mov qword [src], rdi        ; arg1
488b55b8       mov rdx, qword [src]
488d45c0       lea rax, [dest]
4889d6         mov rsi, rdx                ; const char *src
4889c7         mov rdi, rax                ; char *dst
e8c8feffff     call sym.imp.strcpy         ;
488d45c0       lea rax, [dest]
4889c6         mov rsi, rax
488d3d8e0e00   lea rdi, str.dst
b800000000     mov eax, 0
e8c0feffff     call sym.imp.printf
90             nop
c9             leave
c3             ret
```

With the instructions push and pop we insert and extract instructions to/from
the stack. 
With the first three isntruction we push the precedent base pointer of the main 
function, and we "allocate" on the stack 0x50 bytes of space, so the compiler
has increased the dimension of the stack to contain our *dst.
At the end of the function the program issue a leave instruction which moves
the stack pointer to the current base pointer and then it pop the base pointer.
The last instruction is ret which pop from the stack the return address and 
set the instruction pointer to it.

Another type of memory is the heap which is created dynamically using the malloc
instruction.

int *x = (int *)malloc(sizeof(int));

With this instruction we allocate on the heap the size of an int (usually 4B).
When we don't need that space anymore we can free the space on the heap using
free:

free(x);

There are lots of bug around the heap, for example is always good practice to 
check the return value of the malloc, if the dimension requested is too large
the malloc returns NULL. Another good practice is to never reuse a variable
after it has been freed (UAF - Use After Free bugs), or never free twice the
same pointer (Double Free).

To detect potential bugs we can use a tool called valgrind.

Notes that we didn't use syscalls, but library function. At the base of the
malloc there are two syscall:

1. brk/sbrk which increase/decrease the size of the heap.
2. mmap which can create an anonymous memory region (memory not associated with
   any particular file) and that can be treated like a heap.

Never use these two syscalls to manage the heap or the program will crash
with the probability of 99.99%.

-------------------------------------------------------------------------------
Address Translation
-------------------------------------------------------------------------------

The generic technique we will use is something that is referred to as 
hardware-based address translation, or just address translation for short. With
address translation the hardware converts each memmory access changing the
virtual address provided by the instruction to a physical address where the 
desired information is actually located.

Of course, the hardware alone cannot virtualize memory, as it just provides the
low-level mechanism for doing so efficiently. The OS must get involved at key
points to set up the hardware so that the correct translations take place; it
must thus manage memory, keeping track of which locations are free and which are
in use, and judiciously intervening to maintain control over how memory is used.

As scheduling policy we need to do some assumptions to get to a final solution.
The first one is that the user's address space must be placed contiguosly in
physical memory, and that the size of the address space is less than the 
physical memory. Another assumption is that each address space is exactly the
same size.

Process 1 address space:

0KB     -------------------
            Program Code
1KB     -------------------
            Heap
2KB     -------------------
                |
                v

            Free

                ^
                |
15KB    -------------------
            Stack
16KB    -------------------


From the process perspective its address space start at 0KB and end at 16KB,
however the os wants to place the process somewhere else in physical memory not
necessarily at address 0. Example:

Physical memory:

0KB     ------------------
            OS
16KB    ------------------
            Not in Use
32KB    ------------------
            Process 1
48KB    ------------------
            Not in Use
64KB    ------------------

Thus, we want to relocate this process in memory in a way that is transparent
to the process itself.

The first idea introduced on the 1950's is referred as base and bounds, also
called dynamic relocation. Specifically we need two hardware register within
each CPU: one is called base register and the other the bounds/limit. In this
way the program is compiled as if it is loaded at address 0. However, when a 
program starts running, the os decides where in physical memory it should be
loaded and sets the base register to that value. In the above example the os
decides that the process must be relocated to address 32KB and set the base
register = 32KB. Now any memory reference is translated by the processor in the
following manner:

physical address = virtual address + base

If we have an instruction at address 300 like:

300: mov [ebx], eax

The instruction pointer (ip) or program counter (pc) is set to 300 and when
the hardware needs to fetch this instruction, it first add the value to the base
register and obtains as physical address 32KB + 300.
Before fetching the instruction the CPU will check if the memory reference is
within bounds to make sure it is legal (protection), if it's greater than the 
bounds the cpu raise an exception. The base and bounds registers are hardware
structures kept on the chip, and the process that helps the processor with 
address translation is called Memory Management Unit (MMU).

The hardware should provide special privileged (kernel) instruction to change
the base and bound registers, allowing the OS to change them when different
processes run. The os must manage the free space using some kind of data
structures (ex. free list), and when a process terminates update the data
structure. The os must save and restore the base and bounds register in for each
process (for context switch) and uses a structure called Process Control Block
(PCB). A last thing the os must handle the exception generated by the cpu,
usually it kills the process that has tried to access an invalid memory region.
